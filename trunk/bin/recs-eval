#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

use Getopt::Long;
use Recs::InputStream;
use Recs::OutputStream;
use Recs::Record;

Getopt::Long::Configure("pass_through");
GetOptions(
   "help" => \&usage,
);

usage("Must specify an eval statement to run") unless(@ARGV);

my $__MY__code = shift @ARGV;

my $__MY__in = Recs::InputStream->new_magic();

# Variables for use by thee eval block
my $line = 0;
my $r;

while($r = $__MY__in->get_record())
{
   ++$line;
   my $__MY__v;

   {
      no strict;
      no warnings;
      $__MY__v = eval $__MY__code;
   }

   if($@)
   {
      chomp $@;
      warn "Code threw: " . $@ . "\n";
   }
   else
   {
      print $__MY__v . "\n";
   }
}

sub usage
{
   my ($message) = @_;
   if(defined($message))
   {
      print $message . "\n";
   }
   while(my $l = <DATA>)
   {
      print $l;
   }
   exit 1;
}

__DATA__
Usage: recs-eval <args> <expr> [<files>]
   <expr> is evaluated as perl on each record of input (or records from
   <files>) with $r set to a Recs::Record object and $line set to the current
   line number (starting at 1).  The result of each evaluation is printed on a
   line by itself (this is not a recs stream).  See Recs::Record for help on
   what the $r object can do.

Arguments:
   --help   Bail and output this help screen.

Examples:
   Print the host field from each record.
      recs-eval '$r->{host}'
   Prepare to gnuplot field y against field x.
      recs-eval '$r->{x} . " " . $r->{y}'
   Set up a script (this would be presumably piped to sh)
      recs-eval '"./myscript --value $r->{foo}"'
