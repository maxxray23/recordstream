#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

use Getopt::Long;
use Recs::InputStream;
use Recs::OutputStream;
use Recs::Record;

my $no_header = 0;
my @fields;

Getopt::Long::Configure("pass_through");
GetOptions(
   "no-header|n" => \$no_header,
   "field|f=s"   => sub { push @fields, split(/,/, $_[1]); },
   'help'        => \&usage,
);

my %fields;
foreach(@fields)
{
   $fields{$_} = "";
}

my $in = Recs::InputStream->new_magic();

my %widths;
my @r;
my $r;
while($r = $in->get_record())
{
   foreach my $field (keys(%$r))
   {
      if(%fields && !exists($fields{$field}))
      {
         next;
      }
      if(!exists($widths{$field}))
      {
         $widths{$field} = 0;
      }
      $widths{$field} = max($widths{$field}, length($r->{$field}));
   }

   push @r, $r;
}
if(!$no_header)
{
   foreach my $field (keys(%widths))
   {
      $widths{$field} = max($widths{$field}, length($field));
   }
}

if(!@fields)
{
   @fields = sort(keys(%widths));
}

if(!$no_header)
{
   print format_row(\@fields, \%widths, sub { return $_[0]; }, "") . "\n";
   print format_row(\@fields, \%widths, sub { return ("-" x $widths{$_[0]}); }, "") . "\n";
}
foreach my $r (@r)
{
   print format_row(\@fields, \%widths, sub { return (exists($_[1]->{$_[0]}) ? $_[1]->{$_[0]} : ""); }, $r) . "\n";
}

sub format_row
{
   my ($fieldsr, $widthsr, $format_fieldr, $thunk) = @_;

   my $first = 1;
   my $row_string = "";

   foreach my $field (@$fieldsr)
   {
      my $field_string = $format_fieldr->($field, $thunk);

      if(length($field_string) < $widthsr->{$field})
      {
         $field_string .= " " x ($widthsr->{$field} - length($field_string));
      }

      if($first)
      {
         $first = 0;
      }
      else
      {
         $row_string .= "   ";
      }

      $row_string .= $field_string;
   }

   return $row_string;
}

# Hercu-Keith is enragiated
sub max
{
   my $r = 0;
   for(@_)
   {
      if($_ > $r)
      {
         $r = $_;
      }
   }
   return $r;
}

sub usage
{
   my ($message) = @_;
   if(defined($message))
   {
      print $message . "\n";
   }
   while(my $l = <DATA>)
   {
      print $l;
   }
   exit 1;
}

__DATA__
Usage: recs-totable <args> [<files>]
   Pretty prints a table of records to the screen.  Will read in the entire
   record stream to determine column size, and number of columns
   
   --no-header|n           Do not print column headers
   --field|f <field name>  May be comma separated, may be specified multiple
                           times.  Specifies the fields to put in the table.
   --help                  Bail and print this usage

Examples:
   Display a table
      recs-totable
   Display only one field
      recs-totable -f foo
   Display two fields without a header
      recs-totable -f foo -f bar --no-header
