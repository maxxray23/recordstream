#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

use Getopt::Long;
use Recs::OutputStream;
use Recs::Record;

my @fields;

Getopt::Long::Configure("pass_through");
GetOptions(
   "field|f=s" => sub { push @fields, split(/,/, $_[1]); },
   "help"      => \&usage,
);

usage('Must specify a pattern to search for') unless(@ARGV);

my $pattern = shift;

my $out = Recs::OutputStream->new();
while(my $line = <>)
{
   chomp $line;

   if(my @groups = ($line =~ $pattern))
   {
      my %h;
      my $index = 0;

      foreach my $value (@groups)
      {
         $h{$fields[$index] || $index} = $value;
         ++$index;
      }

      my $r = Recs::Record->new(%h);
      $out->put_record($r);
   }
}

sub usage
{
   my ($message) = @_;
   if(defined($message))
   {
      print $message . "\n";
   }
   while(my $l = <DATA>)
   {
      print $l;
   }
   exit 1;
}

__DATA__
Usage: recs-fromre <args> <re> [<files>]
   <re> is matched against each line of input (or lines of <files>).  Each
   successfully match results in one output record whose field values are the
   capture groups from the match.  Lines that do not match are ignored.  Fields
   are named numerically (0, 1, etc.) or as given by --field.

   For spliting on a delimeter, see recs-fromsplit.

Arguments:
   --field|-f <fields>   Comma separated list of field names.  May be specified multiple times.
   --help                Bail and output this help screen.

Examples:
   Parse greetings.
      recs-fromre --field name,age '^Hello, my name is (.*) and I am (\d*) years? old$'
   Parse a single field named time from a group of digits at the beginning of the line.
      recs-fromre --field time '^(\d+)'
   Map three sets of <>s to a record with fields named 0, 1, and 2
      recs-fromre '<(.*)>\s*<(.*)>\s*<(.*)>'
