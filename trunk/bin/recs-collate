#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

use Getopt::Long;
use Recs::Aggregator;
use Recs::InputStream;
use Recs::LRUSheriff;
use Recs::OutputStream;
use Recs::Record;

Recs::Aggregator::load_aggregators();

my @keys;
my @flds;
my $size = 1;
my $cube = 0;
my $cube_default = "ALL";
my $incremental = 0;

Getopt::Long::Configure("pass_through");
GetOptions(
   "key|k=s"           => sub { push @keys, split(/,/, $_[1]); },
   "aggregator|a=s"    => sub { push @flds, split(/:/, $_[1]); },
   "size|sz|n=i"       => \$size,
   "adjacent|1"      => sub { $size = 1; },
   "perfect|p"         => sub { $size = undef; },
   "cube|c"            => \$cube,
   "cube-default=s"    => \$cube_default,
   "incremental|i"     => \$incremental,
   "help"              => \&usage,
   "list-aggregators"  => sub { Recs::Aggregator::list_aggregators(); },
   "show-aggregator=s" => sub { Recs::Aggregator::show_aggregator($_[1]); },
);

usage('Must specify --key or --aggregator') unless ( @keys || @flds );

my $aggrs = Recs::Aggregator::make_aggregators(@flds);

my $lru = Recs::LRUSheriff->new();
my $in = Recs::InputStream->new_magic();
my $out = Recs::OutputStream->new();
my $r;
while($r = $in->get_record())
{
   my $ksr = get_keys($r);
   if($cube)
   {
      deep_put([], $ksr, $r);
   }
   else
   {
      put($ksr, $r);
   }
}
purge(0);

sub deep_put
{
   my ($ksr2, $ksr, $r) = @_;

   if(@$ksr2 == @$ksr)
   {
      put([@$ksr2], $r);
      return;
   }

   push @$ksr2, $cube_default;
   deep_put($ksr2, $ksr, $r);
   pop @$ksr2;

   push @$ksr2, $ksr->[@$ksr2];
   deep_put($ksr2, $ksr, $r);
   pop @$ksr2;
}

sub put
{
   my ($ksr, $r) = @_;

   my $k = canonicalize($ksr);
   my $v = $lru->find($k);
   my $aggr_vals;
   if(!$v)
   {
      $aggr_vals = Recs::Aggregator::map_initial($aggrs);
      $v = [$aggr_vals, $ksr];
      $lru->put($k, $v);
   }
   else
   {
      $aggr_vals = $v->[0];
   }
   $v->[0] = Recs::Aggregator::map_combine($aggrs, $aggr_vals, $r);
   if($incremental)
   {
      output(@$v);
   }
   if(defined($size))
   {
      purge($size);
   }
}

sub purge
{
   my ($size) = @_;

   my @goners = $lru->purgenate($size);
   if(!$incremental)
   {
      for my $v (@goners)
      {
         output(@$v);
      }
   }
}

sub output
{
   my ($aggr_vals, $ksr) = @_;

   my $hr = Recs::Aggregator::map_squish($aggrs, $aggr_vals);
   for(my $i = 0; $i < @keys; ++$i)
   {
      $hr->{$keys[$i]} = $ksr->[$i];
   }

   $out->put_hashref($hr);
}

sub get_keys
{
   my ($r) = @_;

   my @ret;

   for(my $i = 0; $i < @keys; ++$i)
   {
      push @ret, $r->get($keys[$i]);
   }

   return \@ret;
}

sub canonicalize
{
   my ($ar) = @_;
   return join("\x1E", @$ar);
}

sub usage
{
   my ($message) = @_;
   if(defined($message))
   {
      print $message . "\n";
   }
   while(my $l = <DATA>)
   {
      print $l;
   }
   exit 1;
}

__DATA__
Usage: recs-collate <args> [<files>]
   Collate records of input (or records from <files>) into output records.

Arguments:
   --key|-k <keys>               Comma separated list of key fields.
   --aggregator|-a <aggregators> Colon separated list of aggregate field specifiers.
                                 See "Aggregates" section below.
   --size|--sz|-n <number>       Number of running clumps to keep.
   --adjacent|-a|-1              Keep exactly one running clump.
   --perfect                     Never purge clumps until the end.
   --cube                        See "Cubing" section below.
   --cube-default                See "Cubing" section below.
   --incremental                 Output a record every time an input record is added
                                 to a clump (instead of everytime a clump is flushed).

Help / Usage Options:
   --help                         Bail and output this help screen.
   --list-aggregators             Bail and output a list of aggregators.
   --show-aggregator <aggregator> Bail and output this aggregator's detailed usage.

Aggregates:
   Aggregates are specified as [<fieldname>=]<aggregator>[,<arguments>].  The
   default field name is aggregator and arguments joined by underscores.  See
   --list-aggregators for a list of available aggregators.

Cubing:
   Instead of added one entry for each input record, we add 2 ** (number of key
   fields), with every possible combination of fields replaced with the default
   (which defaults to "ALL" but can be specified with --cube-default).  This is
   really supposed to be used with --perfect.  If our key fields were x and y
   then we'd get output records for {x = 1, y = 2}, {x = 1, y = ALL}, {x = ALL,
   y = 2} and {x = ALL, y = ALL}.

Examples:
   Count clumps of adjacent lines with matching x fields.
      recs-collate --adjacent --key x --field count
   Count number of each x field in the entire file.
      recs-collate --perfect --key x --field count
   Count number of each x field in the entire file, including an "ALL" line.
      recs-collate --perfect --key x --field count --cube
   Produce a cummulative sum of field profit up to each date
      recs-collate --key date --incremental --field profit_to_date=sum,profit
   Produce record count for each date, hour pair
      recs-collate --key date,hour --perfect --field count
