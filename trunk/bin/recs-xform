#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

use Getopt::Long;
use Recs::InputStream;
use Recs::OutputStream;
use Recs::Record;

Getopt::Long::Configure("pass_through");
GetOptions(
   "help" => \&usage,
);

usage('Must provide expression to evaluate') unless(@ARGV);

my $__MY__expr = shift;

my $__MY__in = Recs::InputStream->new_magic();
my $__MY__out = Recs::OutputStream->new();
my $line = 0;
my $r;
while($r = $__MY__in->get_record())
{
   ++$line;
   {
      no strict;
      no warnings;
      eval $__MY__expr;
   }
   if($@)
   {
      chomp $@;
      warn "Code threw: " . $@;
   }
   else
   {
      my $records;
      if(ref($r) ne "ARRAY")
      {
         $records = [$r];
      }
      else
      {
         $records = $r;
      }
      for my $record (@$records)
      {
         if(ref($record) eq "Recs::Record")
         {
            $__MY__out->put_record($record);
         }
         elsif(ref($record) eq "HASH")
         {
            $__MY__out->put_hashref($record);
         }
         elsif(ref($record) eq "")
         {
            warn "Found scalar in output";
         }
         else
         {
            warn "Found strange ref in output, ref is " . ref($record);
         }
      }
   }
}

sub usage
{
   my ($message) = @_;
   if(defined($message))
   {
      print $message . "\n";
   }
   while(my $l = <DATA>)
   {
      print $l;
   }
   exit 1;
}

__DATA__
Usage: recs-xform <args> <expr> [<files>]
   <expr> is evaluated as perl on each record of input (or records from
   <files>) with $r set to a Recs::Record object and $line set to the current
   line number (starting at 1).  All records are printed back out (changed as
   they may be).

Arguments:
   --help   Bail and output this help screen.

Examples:
   Add line number to records
      recs-xform '$r->{line} = $line'
   Rename field a to b
      recs-xform '$r->rename("a", "n")'
   Delete field a
      recs-xform '$r->delete("a")'
   Remove fields which are not "a", "b", or "c"
      recs-xform '$r->prune("a", "b", "c")'
