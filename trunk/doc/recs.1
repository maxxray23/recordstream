.\" Automatically generated by Pod::Man version 1.02
.\" Sat Jul 11 00:22:43 2009
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "RECS 1"
.TH RECS 1 "perl v5.6.0" "2009-07-11" "Record Stream System"
.UC
.SH "NAME"
recs \- Record Stream Manipulation and output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A set of programs for creating, manipulating, and outputing a stream of
Records, or hashes.  Inspired by Monad.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The recs system consists of 3 basic sets of scripts.  Input scripts responsible
for generating streams of record objects, Manipulation scripts responsible for
analyzing, select, and manipulating records, and output scripts which take
record streams and produce output for humans.  These scripts can interface with
other systems to retrieve data, parse existing files, or just regex out some
values from a text stream.
.SH "KEY SPECS"
.IX Header "KEY SPECS"
Many of the scripts below take key arguments to specify or assign to a key in a
record. Almost all of the places where you can specify a key (which normally
means a first level key in the record), you can instead specify a key spec.
.PP
A key spec may be nested, and may index into arrays.  Use a '/' to nest into a
hash and a '#NUM' to index into an array (i.e. #2)
.PP
An example is in order, take a record like this:
.PP
{\*(L"biz\*(R":[\*(L"a\*(R",\*(L"b\*(R",\*(L"c\*(R"],\*(L"foo\*(R":{\*(L"bar 1\*(R":1},\*(L"zap\*(R":\*(L"blah1\*(R"}
{\*(L"biz\*(R":[\*(L"a\*(R",\*(L"b\*(R",\*(L"c\*(R"],\*(L"foo\*(R":{\*(L"bar 1\*(R":2},\*(L"zap\*(R":\*(L"blah2\*(R"}
{\*(L"biz\*(R":[\*(L"a\*(R",\*(L"b\*(R",\*(L"c\*(R"],\*(L"foo\*(R":{\*(L"bar 1\*(R":3},\*(L"zap\*(R":\*(L"blah3\*(R"}
.PP
In this case a key spec of 'foo/bar 1' would have the values 1,2, and 3
respectively.
.PP
Similarly, 'biz/#0' would have the value of 'a' for all 3 records
.PP
You can also prefix key specs with '@' to engage the fuzzy matching logic
.PP
Matching works like this in order, first key to match wins
1. Exact match ( eq )
2. Prefix match ( m/^/ )
3. Match anywehre in the key (m//)
.PP
So, in the above example '@b/#2', the 'b' portion would expand to 'biz' and 2
would be the index into the array, so all records would have the value of 'c'
.PP
Simiarly, \f(CW@f\fR/b would have values 1, 2, and 3
.SH "SCRIPTS"
.IX Header "SCRIPTS"
.Sh "Input Generation"
.IX Subsection "Input Generation"
.Ip "recs-fromcsv" 4
.IX Item "recs-fromcsv"
Produces records from a csv file/stream
.Ip "recs-fromdb" 4
.IX Item "recs-fromdb"
Produces records for a db table, or from a \s-1SELECT\s0 statment into a db.
.Ip "recs-fromre" 4
.IX Item "recs-fromre"
Matches input streams against a regex, puts capture groups into hashes
.Ip "recs-frommultire" 4
.IX Item "recs-frommultire"
Matches input streams against several regexs, puts capture groups into the record
.Ip "recs-fromsplit" 4
.IX Item "recs-fromsplit"
Splits input stream on a delimeter
.Ip "recs-fromps" 4
.IX Item "recs-fromps"
Generate records from the process tree
.Ip "recs-fromatomfeed" 4
.IX Item "recs-fromatomfeed"
Produces records for an optionally paginated atom feed.
.Ip "recs-fromxml" 4
.IX Item "recs-fromxml"
Produces records for an \s-1XML\s0 document.
.Ip "recs-fromkv" 4
.IX Item "recs-fromkv"
Produces records from input streams containing loosely formed key/value pairs
.Sh "Stream Manipulation"
.IX Subsection "Stream Manipulation"
.Ip "recs-collate" 4
.IX Item "recs-collate"
Perforce aggregation operations on records.  Group by a field, get an average,
sum, corellation, etc.  Very powerful
.Ip "recs-delta" 4
.IX Item "recs-delta"
Transform values into deltas between adjacent records
.Ip "recs-eval" 4
.IX Item "recs-eval"
Eval a string of perl against each record
.Ip "recs-flatten" 4
.IX Item "recs-flatten"
Flatten records of input to one level
.Ip "recs-grep" 4
.IX Item "recs-grep"
Select records for which a string of perl evaluates to true.
.Ip "recs-normalizetime" 4
.IX Item "recs-normalizetime"
Based on a time field, tag records with a normalized time, i.e. every 5 minute buckets
.Ip "recs-join" 4
.IX Item "recs-join"
Perform an inner join of two record streams.  Associate records in one stream
with another stream.
.Ip "recs-sort" 4
.IX Item "recs-sort"
Sort records based on keys, may specify multiple levels of sorting, as well as
numerical or lexical sort ordering
.Ip "recs-topn" 4
.IX Item "recs-topn"
Outputs the top n records. You may segment the input based on a list of keys
such that unique values of keys are treated as distinct input streams. This
enables top n listings per value groupings.
.Ip "recs-xform" 4
.IX Item "recs-xform"
Perform a block of perl on each record, which may modify the record, Record is
then output
.Ip "recs-generate" 4
.IX Item "recs-generate"
Perform a block of perl on each record to generate a record stream, which is
then output with a chain link back to the original record.
.Sh "Output Generation"
.IX Subsection "Output Generation"
.Ip "recs-todb" 4
.IX Item "recs-todb"
Inserts records into a \s-1DBI\s0 supported \s-1SQL\s0 database.  Will crate a local sqlite
database by default
.Ip "recs-tognuplot" 4
.IX Item "recs-tognuplot"
Create a graph of field values in a record using \s-1GNU\s0 Plot.
=item recs-totable
.Sp
Pretty prints a table of results.
.Ip "recs-tohtml" 4
.IX Item "recs-tohtml"
Prints out an html table of the record stream
.Ip "recs-toprettyprint" 4
.IX Item "recs-toprettyprint"
Prettily prints records, one key to a line, great for making sense of very large records
.Ip "recs-toptable" 4
.IX Item "recs-toptable"
Prints a multi-dimensional (pivot) table of values.  Very powerful.
.SH "NOTES"
.IX Header "NOTES"
The data stream format of the recs scripts is \s-1JSON\s0 hashes separated by new
lines.  If you wish to write your own recs script in your own language, just
get a \s-1JSON\s0 parser and you should be good to go.  The recs scripts use
\&\s-1JSON:\s0:Syck, a fast xs-binding of a c implementation of a \s-1YAML\s0 parser/outputer
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\&  # look in the access log for all accesses with greater than 5 seconds, display in a table
\&  cat access.log | recs-fromre --fieds ip,time '^(\ed+).*TIME: (\ed+)' | recs-grep '$r->{time} > 5' | recs-totable
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Each of the recs-* scripts discussed have a \-\-help mode available to print out
usage and examples for the particular script, See that documentation for
detailed information on the operation of each of the scripts
.SH "AUTHOR"
.IX Header "AUTHOR"
Benjamin Bernard <perlhacker@benjaminbernard.com>
Keith Amling <keith.amling@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007 by Benjamin Bernard and Keith Amling
This software is released under the Public Domain
